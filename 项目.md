### 🎙️ Lua 内存泄漏排查 (STAR 面试话术)

**S - Situation (背景与痛点)**
“这个问题的背景比较严峻。当时我们将游戏从 App 移植到微信小程序，因为小程序对内存有硬性限制（不能超过 2GB）。上线后我们收到了大量 Crash 报告，日志分析显示 Lua 内存经常飙升到 1GB 以上，这是极不正常的，我们判断发生了严重的内存泄漏。”

**T - Task (目标)**
“我的目标非常明确：必须在有限的时间内，定位到这个跨语言环境下的内存泄漏点，把内存控制在安全线以内，止住线上的崩溃。”

**A - Action (行动与技术攻坚)**
我采取了 **‘由表及里，自研工具’** 的三步走策略：

1.  **缩小范围：**
    原先有的全局的Lua内存异常，超过1GB了。通过 VS Profiler 观察内存曲线，我发现‘打开并关闭装备强化窗口’后内存呈阶梯式上涨，无法回落。这帮我锁定了具体的业务场景。

2.  **工具开发（核心）：**
    因为市面上的 Lua Profiler 在小程序环境下很难用，我决定自己写：
    * 我通过自定义 Lua 的内存分配器（Custom Allocator），**Hook** 了所有的 `alloc` 和 `free` 操作。
    * 每当分配内存时，我调用 `lua_getstack` 抓取当前的函数调用栈，把‘调用路径’作为 Key，‘内存大小’作为 Value 存进一个哈希表。
    * 然后我实现了**CaptureMemorySnapShot（获取快照）**和**Snapshot Diff（快照对比）** 功能。在打开窗口前存一次快照，关闭窗口后 GC 再存一次。对比两个快照，那些‘新增且未释放’的堆栈，就是泄漏的元凶。

3.  **精准定位：**
    工具报告指向了一个 `[C]` 类型的函数调用。通过观察Lua代码以及对应行数，发现这个对象类型在C++中是 `Grid` 类。它在初始化时，调用了**registerRef()**，而析构的时候没有正确调用**registerUnRef()**。这意味着 C++ 层一直持有 Lua 注册表的强引用，导致 Lua 的 GC 永远无法回收这块内存。

**R - Result (结果)**
“修复这个问题后，不仅是强化系统，整个游戏运行时的长期内存泄漏都被根治了。小程序的 OOM 崩溃率大幅下降，移动端版本的内存占用也得到了显著优化，极大地提升了稳定性。”

提问： 
1. Lua本身不提供profiler工具么？
    Lua标准库不提供，LuaJIT内置，我们使用的是Lua5.1，得自己写
2. 日常release环境打开么
    不打开，甚至不编译，有问题时才重新编译检查问题，通过hook插桩技术，会带来巨大开销

### 🎙️ 关卡编辑器热更新 (STAR 面试话术)

**S - Situation (背景与痛点)**
“我们在做关卡编辑器时发现一个严重影响效率的问题。美术在 3ds Max 新建模型，必须重启编辑器才能看到效果。我们编辑器启动很慢，而且重启后相机视角也没了，美术得重新找位置，非常搞心态，严重阻塞了开发流程。”

**T - Task (目标)**
“所以我决定做一个**资源热更新功能**。目标是让美术那边一点模型导出，编辑器这边就能直接检测到，并自动把新模型刷出来，不需要重启。”

**A - Action (行动与架构)**
我采用了 **‘观察者模式 + 启发式算法’** 的方案：

1.  **架构设计：**
    我设计了一个 `Observer` 接口，让编辑器的资源面板去继承它。然后改造了 `ResourceMonitor` 类在后台独立线程跑，专门负责监听 Windows 的文件系统消息。当监控到变化时，Monitor 会通知面板刷新。

**2. 难点攻克（核心）：底层 IO 风暴与状态推断**

* **现象:**
    我们发现 3ds Max 等工具的保存机制并非原子操作。一次“保存”在底层会触发**碎片化的事件流**（创建临时文件 -> 多次写入 -> 删除原文件 -> 重命名）。如果直接响应原始事件，编辑器极易读取到不完整的中间文件或被占用的文件，导致崩溃。

* **方案:**
    为了解决这个问题，我设计了一套 **“事件聚合与静默期防抖 (Aggregation & Debouncing)”** 机制：

    * **状态聚合 (Event Coalescing):**
        在监控线程维护一个 `PendingFileMap` 哈希表。当收到 `ReadDirectoryChangesW` 的原始信号（无论是写入、删除还是重命名）时，**不立即执行逻辑**，而是更新 Map 中该文件的时间戳，还有将其存在状态。
    * **静默期机制:**
        利用 **可等待计时器 (Waitable Timer)** 设定 500ms 阈值。每当有新信号，重置计时器。只有当文件在 500ms 内无新信号（进入静默期），才视为一次宏观操作结束。
    * **最终一致性推断 (Inference):**
        当静默期结束触发回调时，执行**最终检查**：
        1.  调用 `GetMarcoActionType` 确认文件当前的物理存在性。
        2.  **逻辑修正：** 若通过了 `Delete` 信号但文件此刻依然存在，则判定为 DCC 工具的“覆盖保存”行为，执行 **Reload** 而非 Unload。

**R - Result (结果)**
“上线后，美术团队反馈非常好。他们再也不用频繁开关编辑器了，资源的迭代效率提升了至少 50%，整个工作流变得非常顺畅。”

### 🎙️ 噪声扭曲材质系统 (STAR 面试话术)

**S - Situation (背景)**
“当时我们的自研引擎需要支持像‘传送门’或‘水面’那样的动态扭曲效果。因为不像 Unity 那样有现成的 Shader Graph，也不支持在编辑器里直接配参数。”

**T - Task (任务)**
“我的任务不仅仅是写一个 Shader，而是要**扩展整套材质渲染管线**。
我需要从底层的 C++ 数据结构入手，打通到上层的 3ds Max 插件，实现一个**‘数据驱动’**的渲染特性，让美术在 Max 里配好导出就能跑。”

**A - Action (行动 - 强调全链路)**
我将工作分为了三个层级：

1.  **工具链层（最有价值的点）：**
    我没有让美术去改配置文件。我直接**修改了 3ds Max 的导出插件源码**，在材质面板新增了‘噪声强度’等参数，并修改 Exporter 将其序列化为 XML。在引擎层，我扩展了 Material 类来解析这些 XML，自动映射到内存中。

2.  **渲染管线层（C++ & HLSL）：**
    这是最底层的工作。我需要在 C++ 层手动管理 Shader 的 **Constant Buffer（常量缓冲区）**。
    * 我在 `InitPSConstantLayout` 中手动注册了 `DistortionPower` 变量，处理好 CPU 和 GPU 的**内存对齐**，确保 C++ 的 float 能准确对应到 HLSL 的寄存器。
    * 同时，我通过 C++ 逻辑动态控制 Shader 宏定义，来管理不同变体的编译。

3.  **性能优化（算法）：**
    为了极致性能，我没有把所有计算都扔给 GPU。
    我策略性地把 UV 动画的矩阵变换放在了 **CPU 层预计算**（在 `beginPass` 阶段完成），然后打包传给 Vertex Shader。这样 Pixel Shader 只需要做最简单的采样和偏移，避免了在每个像素上做矩阵运算，大幅降低了移动端的 GPU 压力。
        传入的扭曲方向、扭曲速度参数，通过极坐标系像单参数方向转成UV方向的偏移，然后乘时间、速度，算出UV的偏移分量。组成4*2的矩阵。

**R - Result (结果)**
“最终实现了一套完全数据驱动的管线。美术人员只需要在 3ds Max 里调好参数，导出即可见。同时由于我在 C++ 层做了优化，这套效果在低端机上的性能非常出色。”

### 🎙️ 室内映射材质 (STAR 面试话术)

**S - Situation (背景)**
“在做城市建筑渲染时，我们面临一个两难的选择：如果给每个窗户后面都建一个 3D 模型房间，渲染面数直接爆炸；如果只贴一张图，玩家走动时窗户里面是平的，完全没有透视感，非常出戏。”

**T - Task (任务)**
“我的目标是实现 **Interior Mapping** 技术。简单说，就是在一个平面的 Quad 上，用数学‘骗’过眼睛，画出一个有深度的房间。”

**A - Action (技术核心)**
我是通过纯 Shader 算出来的，核心逻辑分三步：

1.  **空间构建 (Space Transformation):**
    首先，我在 **切线空间 (Tangent Space)** 下工作。我利用 `frac(UV)` 把大楼表面切分成一个个虚拟的 `1x1x1` 的立方体盒子。

2.  **射线求交 (The Math):**
    这是最难的部分。
    * 我把相机视线（View Vector）射入这个虚拟盒子。
    * 我在 Shader 里通过简单的数学公式：`t = (边界 - 当前点) / 视线向量`，分别计算视线撞到“地板、天花板、后墙、侧墙”的距离。
    * 取最近的那个交点，把它映射回 2D UV。
    * 这样，当玩家移动视角时，看到的墙壁和地板会产生正确的透视形变，感觉就像真的往里看一样。

3.  **随机化 (Randomization):**
    为了不让所有窗户看起来都一样，我用 UV 的整数部分（`floor(UV)`）作为随机种子，在 Shader 里随机偏移 Texture Atlas 的采样坐标。这样每一层的每一个窗户，显示的房间布局、家具都是不一样的。

**R - Result (结果)**
“这个方案性价比极高。我们不需要增加任何顶点，只用一个 Shader 就渲染出了整栋楼成千上万个不同的 3D 房间，而且性能非常稳定，几乎只消耗一些 ALU 计算。”

### 🎙️ Filament 异步资源加载优化 (STAR 面试话术)

**S - Situation (背景与痛点)**
“在负责渲染 SDK 时，我们遇到一个痛点：当用户切换到复杂的 3D 贴纸（比如高精度的面具）时，画面会明显**卡顿一下 (Hiccup)**。
通过批量跑图分析，我发现导致首帧卡顿的核心原因不是 GPU 渲染慢，而是**资源加载堵塞了主线程**。主线程在这一帧里既要读磁盘，又要解析模型资源，还要解码 PNG 图片，导致无法及时提交渲染命令。”

**T - Task (任务)**
“我的目标是实现**资源的异步加载**。我要利用 Filament 的 `JobSystem`，将繁重的 IO 和 CPU 计算任务分发到后台线程，确保主线程在资源准备好之前保持流畅。”

**A - Action (行动 - 技术实现)**
我主要做了三步优化：

1.  **任务拆分 (Task Decomposition):**
    我将加载过程拆解为细粒度的 **Jobs**。特别是 **图片解码 (Image Decoding)**，这是 CPU 消耗大户，我把它封装成独立的 Job 扔给 Worker 线程。

2.  **构建依赖流水线:**
    我利用 `JobSystem` 构建了一个依赖图：`IO Job` 完成后自动触发 `Parsing Job`。这样既充分利用了多核 CPU，又避免了自己开线程导致的**线程爆炸 (Thread Explosion)** 问题（Filament 的线程池是固定核心数的）。

3.  **主线程同步 (核心点):**
    为了处理 OpenGL/Vulkan 的上下文限制，我设计了一个**‘句柄 + 状态检查’**机制。
    * Job 线程只负责把文件解析成内存中的 RGBA 数据。
    * 主线程每帧检查 Job 状态，一旦数据 Ready，主线程只需要做最快的 `memcpy` 或者驱动层上传。
    这样就把 100ms 的阻塞操作化整为零，变成了几毫秒的上传操作。

**R - Result (结果)**
“改造后，特效切换瞬间的 **CPU 主线程耗时降低了 80%**。复杂的 3D 道具做到了‘无感加载’，彻底解决了首帧掉帧问题。”

问题：
1. 多线程任务如果出现先后依赖关系怎么办？
    创建job时，可以指定parent Job。只要子Job还在跑，父Job就被视为未完成
2. 它的工作模式是什么？
    Work Stealing，每个线程都有自己的任务队列，默认只处理队列的最新任务。当线程干完没事时，偷取别的忙碌线程队列最旧的任务。